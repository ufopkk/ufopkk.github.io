[{"title":"大数据开发面试题","date":"2021-06-08T02:18:31.000Z","path":"/posts/6aface50/","text":"bigdata基本知识Shuffle指的是将各节点上同一类数据汇聚到某一节点上进行计算，把分布在不同节点的数据按照一定的规则汇聚到同一节点的过程称为Shuffle。 常见问题 MapReduce Shuffle和Spark Shuffle的区别？MapReduce Shuffle中Shuffle阶段分为Map端的Shuffle和Reduce端的Shuffle。频繁的磁盘I/O会严重影响效率，因此map阶段的中间结果不会立刻写入磁盘，而是优先存储到map节点的“环形内存缓冲区”，在写入的过程中进行分区，对于每个键值对都增加一个partition属性（默认对key取hash值，然后hash值对reduce的个数取余作为partition的属性值），然后以&lt;partition,key,value&gt;的形式序列化为字节数组写入缓冲区。当写入的数据量达到阈值后启动溢出写出线程将缓冲区中的数据写入到磁盘的临时文件中，并在写入前根据key进行排序和合并，使得相同partition的数据汇聚在一起，各个partition内根据key排序。Spark shuffle在DAG构建阶段以shuffle为界，划分stage,上游stage做map task，每一个map task将自己处理的数据按key进行分区，将相同key的数据写入同一个磁盘文件。shuffle write阶段，map task为下游stage的每个task都创建了一个磁盘文件shuffle read阶段下游stage做reduce task,每一个reduce task通过网络拉取上游stage中所有map task的指定分区结果数据。 Spark SQL的连接方式有几种，各自的适用场景是什么？Broadcast Hash Join：适合一张很小的表和一张大表进行Join；hash joinShuffle Hash Join：适合一张小表(比上一个大一点)和一张大表进行Join；Sort Merge Join：适合两张大表进行Join； hive数据库的特点是什么？hive的特点Hive是由Facebook开源的用于解决海量结构化日志的数据统计工具。可以将结构化的数据文件映射为一张表，并提供类SQL查询功能。hive以HDFS为基本的文件存储，以MapReduce为默认执行引擎。优点： 1) 操作接口采用类SQL语法(HQL)，提供快速开发的能力（简单、容易上手）。 2) 避免了用户去写MapReduce程序，减少开发人员的学习成本。 3) Hive的执行延迟比较高，因此Hive常用于数据分析，对实时性要求不高的场合。 4) Hive优势在于处理大数据，对于处理小数据没有优势，因为Hive的执行延迟比较高。 5) Hive支持用户自定义函数，用户可以根据自己的需求来实现自己的函数。缺点： 1）Hive的HQL表达能力有限 （1）迭代式算法无法表达 （2）数据挖掘方面不擅长 2）Hive的效率比较低 （1）Hive自动生成的MapReduce作业，通常情况下不够智能化 （2）Hive调优比较困难，粒度较粗hdfs的架构HDFS采用master/slave架构，这种架构主要由四个部分组成，分别为HDFS Client、NameNode、DataNode和Secondary NameNode。一个HDFS集群是由一个NameNode和一定数目的DataNode组成的。NameNode维护整个hdfs文件系统的元数据信息（目录）负责确定指定的文件块到DataNode节点的映射关系管理DataNode节点的状态报告，包括Datanode结点的健康状态报告和其所在结点上数据块状态报告，以便能够及时处理失效的数据 presto和hive的区别presto是一个facebook开源的分布式SQL查询引擎，适用于交互式分析查询。其采用典型的master-slave模型，coordinator(master)负责meta管理,worker管理，query的解析和调度，worker则负责计算和读写。 hive将一个查询转化为多个MR任务，然后一个接一个执行。执行的中间结果通过对磁盘的读写来同步。Presto没有使用MapReduce，它是通过一个定制的查询和执行引擎来完成的，它的所有的查询处理是在内存中。presto由于是基于内存的，而hive是在磁盘上读写的，因此presto比hive快很多，但是由于是基于内存的当多张大表关联操作时易引起内存溢出错误 MR和Spark的区别 MR是基于进程，spark是基于线程 Spark把运算中数据放到内存中，迭代计算效率会更高；MR的中间结果需要落地磁盘，所以大量的磁盘IO操作，会影响性能 MR的每一个task都是一个进程，当task完成时，进程也会结束，Spark的多个task跑在同一个进程上，这个进程会伴随spark应用程序的整个生命周期，即使没有作业进行，进程也是存在的 spark容错性高，它通过弹性分布式数据集RDD来实现高效容错；MR的话容错可能只能重新计算了，成本较高。 MR运行在yarn上，spark有local、Standalone、Yarn、Messos四种部署模式 spark通用性更强，spark提供了transformation和action这两大类多功能API，另外还有流式处理SparkStreaming模块，机器学习、图计算；MR只提供Map和Reduce方法，没有其他模块，MR其实是有机器学习的基本上没有人使用。 spark框架和生态更为复杂，MR框架及其生态相对较为简单，对性能的要求也相对较弱，但是运行较为稳定，适合长期后台运行 Hbase和Hive的区别Hbase和Hive在大数据架构中处在不同位置，Hbase主要解决实时数据查询问题，Hive主要解决数据处理和计算问题，一般是配合使用。 Hbase: hadoop database, 基于hadoop的数据库，适用于海量明细数据的随机实时查询。hive本质是一个数据仓库，适用于离线的批量数据计算 数仓分层 OSD层（原始数据层），存放原始的数据 DWD（明细数据层） 服务数据层 数据应用层 spark算子transformation算子：map、flatMap、filter、groupByKey、reduceByKey、sortByKeyaction算子：reduce、collect、count()、first()、take、aggregate、foreach、saveAsTextFile flink的窗口时间属性TimeCharacteristic分为三种：ProcessingTime，IngestionTime，EventTime。处理时间：处理流的operator在执行时，所属机器上的本地时间。Processing-time 窗口包含所有在一个时间周期内到达window operator 的events，以本地机器时间衡量。事件时间：事件时间是一个event实际发生的时间，是实际应用最常见的时间语义摄入时间：存在多个Source Operator的情况下，每个 Source Operator可以使用自己本地系统时钟指派 Ingestion Time。后续基于时间相关的各种操作，都会使用数据记录中的 Ingestion Time。 hdfs的缺点： 不支持低延迟数据访问 不适合大量小文件存储 不支持并发写入，一个文件只能有一个写入者 不支持在文件的任意位置进行修改。写操作总是将数据添加在文件的末尾（append） Scala是一种多范式的编程语言，其设计的初衷是要集成面向对象编程和函数式编程的各种特性。Scala运行于Java平台（Java虚拟机），并兼容现有的Java程序。Scala语言表达能力强，一行代码抵得上Java多行，开发速度快；Scala是静态编译的，所以和JRuby,Groovy比起来速度会快很多 数仓建模维度维度表： 星型模型：一张事实表，周围散列多张维度表，维度表都是一级，维度表和事实表之间直接关联。 雪花模型：维度表有多个层级，并且间接和事实表相连。 星座模型：星座模式是星型模式延伸而来，星型模式是基于一张事实表的，而星座模式是基于多张事实表的，而且共享维度信息。","tags":[{"name":"大数据面试","slug":"大数据面试","permalink":"http://ufopkk.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95/"}]},{"title":"Java面试笔记","date":"2021-05-11T01:31:19.000Z","path":"/posts/f9ba3e83/","text":"java数据结构 ArrayList和LinkedList的区别？ArrayList底层使用的是Object数组，而LinkedList底层使用的是双向链表 ArrayList和Vector的区别？Vector是线程安全的 HashTableHashTable&lt;K,V&gt;也是一种key-value结构，它继承自Dictionary&lt;K,V&gt;，实现了Map&lt;K,V&gt;。单线程转为使用HashMap，多线程使用ConcurrentHashMap java自定义注解通过元注解实现Java实现自定义注解 Java多并发编程堆、方法区、程序计数器、Java虚拟机栈、本地方法栈线程私有：程序计数器、Java虚拟机栈、本地方法栈线程共有：堆和方法区程序计数器：一块较小的内存空间，可以看作当前线程所执行字节码的行号指示器，字节码解释器工作时通过改变计数器的值选择下一条指令。分支、循环、跳转以及线程恢复等功能都要依赖程序计数器完成。如果线程正在执行Java方法，记录正在执行的虚拟机字节码指令地址；如果执行本地方法，计数器值为Undefined。Java虚拟机栈：用来描述Java方法的内存模型，当有线程创建时就会分配一个栈空间，线程销毁时回收栈空间，栈与线程的生命周期相同。栈中元素用于支持虚拟机进行方法调用，每个方法在执行时会创建一个栈帧用于存储局部变量表、操作栈、动态链接和方法出口等信息。每个方法从调用到执行完成，就是栈帧从入栈到出栈的过程。方法区用于存储被虚拟机加载的类型信息、常量、静态变量，即时编译器编译的代码缓存等数据。 synchronized的底层多线程 产生死锁的四个条件 互斥条件：任意时刻某个资源只由一个线程占有 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。 如何预防和避免死锁 破坏请求与保持条件 AQS设计模式7大原则23种模式创建型5种、结构型7种、行为型11种创建型： 单例模式、原型模式、简单工厂模式、工厂方法模式、抽象工厂模式结构型： 代理模式、适配器模式、桥接模式、装饰模式、外观模式、享元模式、组合模式 网络常见问题 http和https的区别 http是超文本传输协议，信息是明文传输，而https是由超文本传输协议和安全通讯层（SSL）构建的可进行加密传输、身份认证的网络协议，比http协议安全 http和https使用的是完全不同的连接方式，使用的端口也不同。http使用80端口，https使用443端口。 OSI(开放式系统互联通信参考模型),OSI七层参考模型内容物理层–&gt;数据链路层–&gt;网络层–&gt;传输层–&gt;会话层–&gt;表示层–&gt;应用层常见的应用层服务协议包括：HTTP、HTTPS、FTP、POP3、SMTP、DNS等。传输层协议包括：TCP和UDP网络层协议：IP、ICMP、RIP、IGMP数据链路层协议:ARP、RARP、PPP TCP(传输控制协议),UDP(用户数据报协议)TCP五层协议：物理层–&gt;数据链路层–&gt;网络层–&gt;传输层–&gt;应用层 TCP的三次握手和四次握手 Java动态代理和CGLib（code generation library）动态代理jdk动态代理要求被代理对象必须要实现接口，才能生成代理对象。cglib:可以对任何类生成代理，代理的原理是对目标对象进行继承代理，如果目标对象被final修饰，则该类无法被cglib动态代理。 Java面试易错题类加载将类信息加载到内存中，类的初始化 12345678910111213141516public class P {public static int abc = 123;static{System.out.println(\"P is init\");}}public class S extends P {static{System.out.println(\"S is init\");}}public class Test {public static void main(String[] args) {System.out.println(S.abc);}} 子类引用父类的静态字段，只会触发子类的加载、父类的初始化，不会触发子类的初始化。 通过数组定义来引用类，不会触发此类的初始化 12345public class NotInitialization { public static void main(String[] args) { SuperClass[] sca = new SuperClass[10]; } } .常量在编译阶段会进行常量优化，将常量存入调用类的常量池中， 本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化. 12345678910111213public class ConstClass { static { System.out.println(\"ConstClass init!\"); } public static final int value = 123; } public class NotInitialization{ public static void main(String[] args) { int x = ConstClass.value; } } //上述代码运行之后，不输出“ConstClass init！” Java中的内部类Java中可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。内部类分为：成员内部类、局部内部类和匿名内部类。 成员内部类 该类像外部类的一个成员，可以无条件访问外部类的所有成员属性和成员方法。 局部内部类 局部内部类是定义在一个方法或者一个作用阈中的类，它和成员内部类的区别在于局部内部类的访问权限仅限于方法内或作用域内；局部内部类像方法中的局部变量一样，不能被public、private、protected和static等修饰符修饰。 匿名内部类 匿名内部类定义形式：new 父类构造器（无参|有参）| 实现接口（）{@Override}使用匿名内部类必须继承一个类或者实现一个接口，但是两者不能同时实现，只能继承一个类或者实现一个接口匿名内部类中不能定义构造方法匿名内部类中不能存在静态成员变量和静态方法匿名内部类不能是抽象的，必须实现继承的类或者实现接口中所有的抽象方法。 静态内部类 静态内部类不需要依赖于外部类，和类的静态成员类似。不能使用外部类的非静态成员变量和方法。 线程池Java线程池七个参数详解 线程池拒绝策略四种线程池拒绝策略当线程池的任务缓冲队列已满并且线程池中的线程数量达到maximunPoolSize时，还有新任务到来就会采用拒绝策略通常有以下四种策略：ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务ThreadPoolExecutor.CallerRunsPolicy：由调用线程（提交任务的线程）处理该任务 Spring解决循环依赖的方法Spring中循环依赖的场景： 构造器的循环依赖； filed属性的循环依赖；Spring的循环依赖理论是基于Java的引用传递，当获取到对象的引用时，对象的属性是可以延后设置的(但是构造器必须是在获取引用之前)。Spring单例对象的初始化主要分为： 循环依赖就是N个类循环嵌套引用，用new 对象的方式发生这种循环依赖的话程序会在运行时一直循环调用，直至内存溢出报错。无法解决构造器注入构成的循环依赖 setter方式注入，bean的作用域为“singleton”。Spring容器首先构造实例化Bean对象，Spring会将实例化后的对象加入ConcurrentHashMap中，Spring提供了获取这个未设置属性的实例化对象引用的方法。 对于“prototype”作用域Bean，Spring容器无法完成依赖注入，因为“prototype”作用域的Bean，Spring容器不进行缓存，因此无法提前暴露一个创建中的Bean Spring常用注解 包扫描+组件标注注解 @Component:泛指各种组件，包括@Controller、@Service、@Repository 注入Bean相关注解 @Bean 明确地指示了一种产生一个bean的方法，并且交给Spring容器管理。支持别名@Bean(“xx-name”) @Scope,作用在类和方法上，用来配置bean的作用域。 1234567891011@Scope(value=\"\",proxyMode=\"\")value: singleton 表示bean是单例的 prototype 表示bean是多例的 request 一次http请求，一个bean对应一个实例 session 在一个httpSession中，一个bean对应一个实例。proxyMode DEFAULT 不使用代理。(默认) NO 不使用代理，等价于DEFAULT。 INTERFACES 使用基于接口的代理(jdk dynamic proxy)。 TARGET_CLASS 使用基于类的代理(cglib)。 bean的导入 12345@Autowired 自动导入@Inject@Resource@Primary@Qualifier Controller相关注解 @RestController,@Controller+@ResponseBody，将方法返回的对象以json格式返回给浏览器 @RequestBody 通过HttpMessageConverter读取Request Body并反序列化为Object（泛指）对象 @RequestMapping，将 HTTP 请求映射到 MVC 和 REST 控制器的处理方法上 1234@GetMapping用于将HTTP get请求映射到特定处理程序的方法注解@RequestMapping(value = \"/say\",method = RequestMethod.GET) == @GetMapping(value = \"/say\")@PostMapping用于将HTTP post请求映射到特定处理程序的方法注解@RequestMapping(method = RequestMethod.POST) == @PostMapping 获取请求参数 1234567891011121314@PathVariable 获取url中的数据@RequestMapping(\"/getUser/{uid}\")public String getUser(@PathVariable(\"uid\")Integer id, Model model) { System.out.println(\"id:\"+id); return \"user\";}@RequestParam 获取请求参数的值@RequestMapping(\"/getUser\")public String getUser(@RequestParam(\"uid\")Integer id, Model model) { System.out.println(\"id:\"+id); return \"user\";} 事务注解 @Tansactional，Spring中，事务有编程式事务管理和声明式事务管理两种方式 JDK1.8新特性 什么时候会出现空指针异常（NullPointerException）？ optional处理空值空值异常是java应用程序失败的主要原因 12optional.of(); //把 null 值作为参数传递进去，of() 方法会抛出 NullPointerExceptionoptional.ofNullable(); //对象即可能是 null 也可能是非 null","tags":[{"name":"Java面试","slug":"Java面试","permalink":"http://ufopkk.github.io/tags/Java%E9%9D%A2%E8%AF%95/"}]},{"title":"latex常用数学符号","date":"2021-05-09T03:15:25.000Z","path":"/posts/2f6be78b/","text":"word公式编辑 常用符号数据库常用符号 定界符 符号 Latex命令 符号 Latex命令 符号 Latex命令 符号 Latex命令 ( ( ) ) [ [或\\lbrack ] ]或\\rbrack [[ \\llbracket ]] \\rrbracket { {或\\lbrace } }或\\rbrace 大定界符 符号 Latex命令 符号 Latex命令 符号 Latex命令 符号 Latex命令 ( ( ) ) [ [或\\lbrack ] ]或\\rbrack [[ \\llbracket ]] \\rrbracket { {或\\lbrace } }或\\rbrace AMS 二元关系 符号 Latex命令 符号 Latex命令 符号 Latex命令 符号 Latex命令 ⋖ \\lessdot ⋗ \\gtrdot ≑ \\doteqdot ⩽ \\leqslant ⩾ \\geqslant ≓ \\risingdotseq ⪕ \\eqslantless ⪖ \\eqslantgtr ≒ \\fallingdotseq ≦ \\leqq ≧ \\geqq ≖ \\eqcirc ⋘ \\lll 或 \\llless ⋙ \\ggg ≗ \\circeq ≲ \\lesssim 空心中括号\\usepackage{stmaryrd}$\\llbracket{x=0}\\rrbracket$","tags":[{"name":"latex语法","slug":"latex语法","permalink":"http://ufopkk.github.io/tags/latex%E8%AF%AD%E6%B3%95/"}]},{"title":"基于hexo和github搭建博客","date":"2021-04-27T09:54:52.000Z","path":"/posts/38872/","text":"command hexo inithexo init用于初始化本地文件夹为网站的根目录 12hexo init [folder]hexo deploy hexo -d hexo newhexo new用于新建文章 123hexo new [layout] &lt;title&gt;layout 可选参数，用以指定文章类型，若无指定则默认由配置文件中的 default_layout 选项决定title 必填参数，用以指定文章标题，如果参数值中含有空格，则需要使用双引号包围 hexo serverhexo server / hexo s用于启动本地服务器 1234hexo server [-p] [-i] [-s]-p 选项，指定服务器端口，默认为 4000-i 选项，指定服务器 IP 地址，默认为 0.0.0.0-s 选项，静态模式 ，仅提供 public 文件夹中的文件并禁用文件监视 hexo generatehexo generate / hexo g用于生成静态网页 1hexo g --watch #监视文件变动 hexo deployhexo deploy / hexo d用于部署到远程服务器 12hexo generate --deployhexo deploy --generate 更换主题 安装next主题，以npm方式进行安装1$ npm install hexo-theme-next@latest 修改主题123cd ${project_root}\\_config.ymltheme: next #启用next主题$ hexo generate 更换样式1234567cd ${project_root}\\node_modules\\hexo-theme-next\\_config.yml对next模板的默认Muse进行修改# Schemes#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 如何在文章中插入图片 修改站点配置文件123cd ${project_root}vim ${project_root}\\_config.ymlpost_asset_folder: true #将此项设置为true 安装插件npm install https://github.com/CodeFalling/hexo-asset-image – save 插入图片运行hexo n “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片插入格式为 ![图片描述](xxxx/图片名.jpg) 自定义主题本站中使用了tomotoes主题 更多主题可参考 https://hexo.io/themes/ 常见问题 123456```bashcd ${project_root}npm install lodash #在项目根目录下安装lodash组件cd ${project_root}\\node_modules\\hexo\\package.json vim package.json添加 \"lodash\": \"4.17.21\" 12vim ${project_root}\\node_modules\\hexo\\lib\\hexo\\index.js 添加 const _ = require(\"lodash\"); 和this._ = _; 设置https://my.oschina.net/zhengqingya/blog/3070979","tags":[{"name":"技术分享","slug":"技术分享","permalink":"http://ufopkk.github.io/tags/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}]},{"title":"论文画图","date":"2021-04-27T09:46:08.000Z","path":"/posts/36630/","text":"","tags":[]}]